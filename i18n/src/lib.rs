//! Localization system of simple-icons website

use leptos::*;
use std::collections::HashMap;
use std::str::FromStr;

#[derive(Clone, Copy)]
pub struct Language {
    /// Language code
    pub code: &'static str,
    /// Language name
    pub name: &'static str,
}

impl PartialEq for Language {
    fn eq(&self, other: &Self) -> bool {
        self.code == other.code
    }
}

pub static LANGUAGES: [Language; 9] = [
    Language {
        code: "en",
        name: "English",
    },
    Language {
        code: "es",
        name: "Español",
    },
    Language {
        code: "fr",
        name: "Français",
    },
    Language {
        code: "it",
        name: "Italiano",
    },
    Language {
        code: "ja-JP",
        name: "日本語",
    },
    Language {
        code: "pt",
        name: "Português",
    },
    Language {
        code: "zh-CN",
        name: "中文 (简体)",
    },
    Language {
        code: "zh-HK",
        name: "中文 (香港)",
    },
    Language {
        code: "zh-TW",
        name: "中文 (繁體)",
    },
];

impl Language {
    pub fn translate(&self, key: &'static str) -> String {
        TRANSLATIONS
            .get(self.code)
            .and_then(|translations| translations.get(key))
            .unwrap_or(&key.to_string())
            .to_string()
    }
}

impl FromStr for Language {
    type Err = ();

    fn from_str(code: &str) -> Result<Self, Self::Err> {
        match LANGUAGES.iter().find(|lang| lang.code == code).copied() {
            Some(lang) => Ok(lang),
            None => Err(()),
        }
    }
}

impl Default for Language {
    fn default() -> Self {
        LANGUAGES[0]
    }
}

// Translations are generated by the build.rs script
include!(concat!(env!("OUT_DIR"), "/translations.rs"));

#[derive(Copy, Clone)]
pub struct LocaleSignal(pub RwSignal<Language>);

#[macro_export]
macro_rules! gettext_impl {
    ($key:expr) => {
        ((&use_context::<::i18n::LocaleSignal>().unwrap().0)().translate($key))
            .to_string()
    };
}

#[macro_export]
macro_rules! replace_impl {
    ($key:expr, $($replacements:expr),+) => {
        {
            let mut string = $key.to_string();
            $(
                string = string.replacen("{}", $replacements, 1);
            )+
            string
        }
    };
}

/// Macro to translate strings in the website
///
/// Use it like this:
///
/// ```rust,ignore
/// <p>{move || gettext!( "Hello world!")}</p>
/// ```
///
/// You need to wrap in a `move` closure because is the way that Leptos
/// has to know that the string is reactive.
///
/// ## Interpolation
///
/// You can interpolate variables in the string like with `format!()`,
/// but only `{}` interpolations are supported.
///
/// ```rust,ignore
/// <p>{move || gettext!( "{} {}!", "Hello", "world")}</p>
/// ```
#[macro_export]
macro_rules! gettext {
    ($key:expr) => {
        $crate::gettext_impl!($key)
    };
    ($key:expr, $($replacements:expr),+) => {
        $crate::replace_impl!($crate::gettext_impl!($key), $($replacements),+)
    };
}

/// Macro to generate a closure that returns a translated string
///
/// Convenient wrapper for Leptos interactivity closures.
///
/// Use it like this:
/// ```rust,ignore
/// <p>{move_gettext!( "Hello world!")}</p>
/// ```
///
/// The previous code is the same as:
/// ```rust,ignore
/// <p>{move || gettext!( "Hello world!")}</p>
/// ```
#[macro_export]
macro_rules! move_gettext {
    ($key:expr) => {
        move||$crate::gettext!($key)
    };
    ($key:expr, $($replacements:expr),+) => {
        move||$crate::gettext!($key, $($replacements),+)
    };
}
